#!/usr/bin/env python3
"""
Convert an explicit person travel chain JSON into a SUMO routes file (<person> with <walk>/<ride> stages).

This is meant to work with MobilityGeneration outputs (mapped busStops + PT vehicles).

Typical usage:
  python3 tools/person_chain_to_sumo.py \
    --plan examples/person_chain/plan_nyc_subway1_busB42.json \
    --line-map examples/person_chain/line_map_strip_prefix.json \
    --output examples/person_chain/out_person.rou.xml
"""

from __future__ import annotations

import argparse
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Tuple
import xml.etree.ElementTree as ET


@dataclass(frozen=True)
class Ref:
    kind: str  # "edge" | "busStop"
    value: str


def _load_json(path: Path) -> Any:
    return json.loads(path.read_text(encoding="utf-8"))


def _parse_ref(obj: Dict[str, Any]) -> Ref:
    if not isinstance(obj, dict):
        raise ValueError(f"Expected object for ref, got {type(obj).__name__}")
    if "edge" in obj:
        return Ref("edge", str(obj["edge"]))
    if "busStop" in obj:
        return Ref("busStop", str(obj["busStop"]))
    raise ValueError(f"Ref must contain 'edge' or 'busStop', got keys={sorted(obj.keys())}")


def _load_line_map(path: Optional[Path]) -> Dict[str, str]:
    if path is None:
        return {}
    mapping = _load_json(path)
    if not isinstance(mapping, dict):
        raise ValueError("line-map must be a JSON object of {inputLine: sumoLine}")
    return {str(k): str(v) for k, v in mapping.items()}


def _map_lines(lines: Iterable[str], line_map: Dict[str, str], strip_prefixes: Tuple[str, ...]) -> List[str]:
    mapped: List[str] = []
    for raw in lines:
        raw = str(raw)
        if raw in line_map:
            mapped.append(line_map[raw])
            continue
        for prefix in strip_prefixes:
            if raw.startswith(prefix):
                mapped.append(raw[len(prefix) :])
                break
        else:
            mapped.append(raw)
    # de-dup while keeping order
    seen = set()
    out: List[str] = []
    for line in mapped:
        if line not in seen:
            seen.add(line)
            out.append(line)
    return out


def _validate_plan(plan: Dict[str, Any]) -> None:
    if not isinstance(plan, dict):
        raise ValueError("Plan must be a JSON object")
    if "personId" not in plan or not str(plan["personId"]).strip():
        raise ValueError("Missing/empty 'personId'")
    if "depart" not in plan:
        raise ValueError("Missing 'depart'")
    if not isinstance(plan.get("legs"), list) or not plan["legs"]:
        raise ValueError("'legs' must be a non-empty list")

    for idx, leg in enumerate(plan["legs"]):
        if not isinstance(leg, dict):
            raise ValueError(f"Leg #{idx} must be an object")
        if leg.get("type") not in {"walk", "ride"}:
            raise ValueError(f"Leg #{idx} has invalid type={leg.get('type')!r} (expected walk/ride)")
        if "from" not in leg or "to" not in leg:
            raise ValueError(f"Leg #{idx} must include 'from' and 'to'")
        _parse_ref(leg["from"])
        _parse_ref(leg["to"])
        if leg["type"] == "ride":
            if not isinstance(leg.get("lines"), list) or not leg["lines"]:
                raise ValueError(f"Leg #{idx} (ride) must include non-empty 'lines' list")


def _render_person_routes(
    plan: Dict[str, Any],
    line_map: Dict[str, str],
    strip_prefixes: Tuple[str, ...],
    strict_continuity: bool,
) -> ET.ElementTree:
    _validate_plan(plan)

    person_id = str(plan["personId"])
    depart = str(plan["depart"])

    root = ET.Element("routes")
    root.set("xmlns:xsi", "http://www.w3.org/2001/XMLSchema-instance")
    root.set("xsi:noNamespaceSchemaLocation", "http://sumo.dlr.de/xsd/routes_file.xsd")

    comment = ET.Comment(
        "Generated by tools/person_chain_to_sumo.py from an explicit person chain JSON.\n"
        "This file is intended to be loaded alongside PT vehicle route files and PT stop additional files."
    )
    root.append(comment)

    person = ET.SubElement(root, "person")
    person.set("id", person_id)
    person.set("depart", depart)

    current: Optional[Ref] = None

    for idx, leg in enumerate(plan["legs"]):
        leg_type = leg["type"]
        from_ref = _parse_ref(leg["from"])
        to_ref = _parse_ref(leg["to"])

        # Enforce or repair continuity: the leg 'from' must match the current location.
        if current is None:
            current = from_ref
        elif current != from_ref:
            if not strict_continuity and from_ref.kind == "busStop":
                # Insert a walk to the required busStop to repair.
                walk_fix = ET.SubElement(person, "walk")
                walk_fix.set("busStop", from_ref.value)
                current = from_ref
            else:
                raise ValueError(
                    f"Plan continuity error at leg #{idx}: current={current.kind}:{current.value} "
                    f"but leg.from={from_ref.kind}:{from_ref.value}"
                )

        if leg_type == "walk":
            walk = ET.SubElement(person, "walk")
            # Only edges are portable as explicit origins in SUMO stage definitions.
            if from_ref.kind == "edge" and (idx == 0 or strict_continuity):
                walk.set("from", from_ref.value)

            if to_ref.kind == "busStop":
                walk.set("busStop", to_ref.value)
            else:
                walk.set("to", to_ref.value)

        elif leg_type == "ride":
            ride = ET.SubElement(person, "ride")
            mapped_lines = _map_lines(leg["lines"], line_map=line_map, strip_prefixes=strip_prefixes)
            ride.set("lines", " ".join(mapped_lines))

            if to_ref.kind == "busStop":
                ride.set("busStop", to_ref.value)
            else:
                ride.set("to", to_ref.value)
        else:
            raise AssertionError("unreachable")

        current = to_ref

    ET.indent(root, space="  ", level=0)
    return ET.ElementTree(root)


def main() -> int:
    parser = argparse.ArgumentParser(description="Convert explicit person chain JSON to SUMO person routes XML")
    parser.add_argument("--plan", required=True, help="Path to plan JSON")
    parser.add_argument("--output", required=True, help="Output .rou.xml file path")
    parser.add_argument("--line-map", help="Optional JSON mapping {inputLine: sumoLine}")
    parser.add_argument(
        "--strip-line-prefix",
        action="append",
        default=["subway:", "bus:"],
        help="If no explicit mapping exists, strip this prefix from a line label (repeatable). Default: subway:, bus:",
    )
    parser.add_argument(
        "--strict-continuity",
        action="store_true",
        help="Fail if leg.from does not equal previous leg.to (default: auto-insert walk to required busStop when possible)",
    )

    args = parser.parse_args()

    plan = _load_json(Path(args.plan))
    line_map = _load_line_map(Path(args.line_map) if args.line_map else None)
    strip_prefixes = tuple(str(p) for p in args.strip_line_prefix)

    tree = _render_person_routes(
        plan=plan,
        line_map=line_map,
        strip_prefixes=strip_prefixes,
        strict_continuity=args.strict_continuity,
    )
    out_path = Path(args.output)
    out_path.parent.mkdir(parents=True, exist_ok=True)
    tree.write(out_path, encoding="utf-8", xml_declaration=True)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

